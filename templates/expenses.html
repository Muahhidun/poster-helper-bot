{% extends "base.html" %}

{% block title %}–†–∞—Å—Ö–æ–¥—ã - PizzBurg{% endblock %}

{% block content %}
<div class="container">
    <h1>–ß–µ—Ä–Ω–æ–≤–∏–∫–∏ —Ä–∞—Å—Ö–æ–¥–æ–≤</h1>

    <form id="drafts-form" method="POST">
        <div class="drafts-actions">
            <button type="button" class="btn btn-primary" id="add-row-btn">
                ‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É
            </button>
            <button type="submit" formaction="{{ url_for('process_drafts') }}" class="btn btn-success">
                ‚úÖ –°–æ–∑–¥–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            </button>
            <button type="submit" formaction="{{ url_for('delete_drafts') }}" class="btn btn-danger"
                    onclick="return confirm('–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ?')">
                üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ
            </button>
            <span class="selected-count">–í—ã–±—Ä–∞–Ω–æ: <span id="count">0</span></span>
        </div>

        <div class="sync-legend">
            <span class="legend-item"><span class="dot green"></span> –°–æ–≤–ø–∞–ª–æ 4/4 (—É–∂–µ –≤ Poster)</span>
            <span class="legend-item"><span class="dot yellow"></span> –°–æ–≤–ø–∞–ª–æ 3/4 (—á–∞—Å—Ç–∏—á–Ω–æ–µ)</span>
            <span class="legend-item"><span class="dot none"></span> –ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤ Poster</span>
        </div>

        {% if drafts or True %}
        <table class="table">
            <thead>
                <tr>
                    <th><input type="checkbox" id="select-all"></th>
                    <th>‚úì</th>
                    <th>–°—É–º–º–∞</th>
                    <th>–û–ø–∏—Å–∞–Ω–∏–µ</th>
                    <th>–¢–∏–ø</th>
                    <th>–ö–∞—Ç–µ–≥–æ—Ä–∏—è</th>
                    <th>–°—á—ë—Ç —Å–ø–∏—Å–∞–Ω–∏—è</th>
                    <th>–û—Ç–¥–µ–ª</th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="drafts-tbody">
                {% for draft in drafts %}
                <tr class="draft-row {% if draft.expense_type == 'supply' %}supply{% else %}transaction{% endif %} {% if draft.completion_status == 'completed' %}completed{% elif draft.completion_status == 'partial' %}partial{% endif %}"
                    data-id="{{ draft.id }}"
                    data-amount="{{ draft.amount|int }}"
                    data-description="{{ draft.description }}"
                    data-category="{{ draft.category or '' }}"
                    data-account-id="{{ draft.account_id or '' }}"
                    data-poster-account-id="{{ draft.poster_account_id or '' }}"
                    data-completion-status="{{ draft.completion_status or 'pending' }}">
                    <td>
                        <input type="checkbox" name="draft_ids" value="{{ draft.id }}" class="draft-checkbox">
                    </td>
                    <td class="completion-status">
                        <button type="button" class="btn-completion" data-id="{{ draft.id }}" data-status="{{ draft.completion_status or 'pending' }}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                            {% if draft.completion_status == 'completed' %}‚úÖ
                            {% elif draft.completion_status == 'partial' %}üü°
                            {% else %}‚ö™{% endif %}
                        </button>
                    </td>
                    <td class="amount">
                        <input type="number" class="edit-amount" value="{{ draft.amount|int }}"
                               data-id="{{ draft.id }}" step="1" min="0">
                    </td>
                    <td class="description">
                        <input type="text" class="edit-description" value="{{ draft.description }}"
                               data-id="{{ draft.id }}">
                    </td>
                    <td class="type">
                        <button type="button" class="btn-type"
                                data-id="{{ draft.id }}"
                                data-type="{{ draft.expense_type }}">
                            {% if draft.expense_type == 'supply' %}
                                üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞
                            {% else %}
                                üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
                            {% endif %}
                        </button>
                    </td>
                    <td class="category">
                        <div class="autocomplete-wrapper">
                            <input type="text" class="edit-category"
                                   value="{{ draft.category or '' }}"
                                   data-id="{{ draft.id }}"
                                   placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                                   autocomplete="off">
                            <div class="autocomplete-results"></div>
                        </div>
                    </td>
                    <td class="account">
                        <select class="edit-account" data-id="{{ draft.id }}" data-source="{{ draft.source }}" data-poster-account-id="{{ draft.poster_account_id or '' }}">
                            {% for acc in accounts %}
                            {% if not draft.poster_account_id or acc.poster_account_id == draft.poster_account_id %}
                            <option value="{{ acc.account_id }}"
                                    data-name="{{ acc.name|lower }}"
                                    data-poster-account-id="{{ acc.poster_account_id }}"
                                    {% if draft.account_id == acc.account_id %}selected
                                    {% elif not draft.account_id and draft.source == 'kaspi' and 'kaspi' in acc.name|lower %}selected
                                    {% elif not draft.account_id and draft.source != 'kaspi' and ('–∑–∞–∫—É–ø' in acc.name|lower or '–æ—Å—Ç–∞–≤–∏–ª' in acc.name|lower) %}selected
                                    {% endif %}>
                                {{ acc.name }}
                            </option>
                            {% endif %}
                            {% endfor %}
                        </select>
                    </td>
                    <td class="poster-account">
                        <select class="edit-poster-account" data-id="{{ draft.id }}">
                            {% for pa in poster_accounts %}
                            <option value="{{ pa.id }}"
                                    {% if draft.poster_account_id == pa.id %}selected
                                    {% elif not draft.poster_account_id and pa.is_primary %}selected
                                    {% endif %}>
                                {{ pa.name }}
                            </option>
                            {% endfor %}
                        </select>
                    </td>
                    <td class="actions">
                        <button type="button" class="btn-delete" data-id="{{ draft.id }}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% endif %}

        <div class="summary">
            <p>–í—Å–µ–≥–æ: <span id="total-count">{{ drafts|length }}</span> –∑–∞–ø–∏—Å–µ–π</p>
            <p>üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: <span id="transaction-count">{{ drafts|selectattr('expense_type', 'equalto', 'transaction')|list|length }}</span></p>
            <p>üì¶ –ü–æ—Å—Ç–∞–≤–æ–∫: <span id="supply-count">{{ drafts|selectattr('expense_type', 'equalto', 'supply')|list|length }}</span></p>
            <p><strong>–°—É–º–º–∞: <span id="total-sum">{{ "{:,.0f}".format(drafts|sum(attribute='amount')) }}</span>‚Ç∏</strong></p>
        </div>
    </form>

    {% if not drafts %}
    <div class="empty-state">
        <p>–ù–µ—Ç —á–µ—Ä–Ω–æ–≤–∏–∫–æ–≤ —Ä–∞—Å—Ö–æ–¥–æ–≤</p>
        <p>–ù–∞–∂–º–∏—Ç–µ "–î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É" –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/Kaspi –≤—ã–ø–∏—Å–∫—É –≤ –±–æ—Ç–∞.</p>
    </div>
    {% endif %}
</div>

<style>
.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

h1 {
    margin-bottom: 20px;
}

.drafts-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
    flex-wrap: wrap;
}

.sync-legend {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
    font-size: 12px;
    color: #666;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
}

.dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
}

.dot.green { background: #28a745; }
.dot.yellow { background: #ffc107; }
.dot.none { background: #e0e0e0; border: 1px solid #ccc; }

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
}

.btn-primary {
    background: #007bff;
    color: white;
}

.btn-success {
    background: #28a745;
    color: white;
}

.btn-danger {
    background: #dc3545;
    color: white;
}

.btn:hover {
    opacity: 0.9;
}

.selected-count {
    margin-left: auto;
    color: #666;
}

.table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
}

.table th, .table td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

.table th {
    background: #f5f5f5;
    font-weight: 600;
    white-space: nowrap;
}

.draft-row:hover {
    background: #f9f9f9;
}

.draft-row.supply {
    border-left: 4px solid #17a2b8;
}

.draft-row.transaction {
    border-left: 4px solid #28a745;
}

/* Completion status styles */
.draft-row.partial {
    background: #fff8e6 !important;
}

.draft-row.partial .edit-description {
    text-decoration: underline;
}

.draft-row.completed {
    background: #e8f5e9 !important;
    opacity: 0.85;
}

.btn-completion {
    border: none;
    background: none;
    font-size: 18px;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
}

.btn-completion:hover {
    background: #f0f0f0;
}

/* Sync status colors */
.draft-row.sync-full {
    background: #d4edda !important;
}

.draft-row.sync-partial {
    background: #fff3cd !important;
}

/* Editable inputs */
.edit-amount {
    width: 90px;
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
    text-align: right;
    font-family: monospace;
    font-weight: 600;
}

.edit-description {
    width: 160px;
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
}

.edit-category {
    width: 110px;
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
}

.edit-account {
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
    background: white;
    width: 140px;
}

.edit-poster-account {
    padding: 4px 6px;
    border: 1px solid #ddd;
    border-radius: 3px;
    background: white;
    width: 130px;
}

/* Autocomplete */
.autocomplete-wrapper {
    position: relative;
}

.autocomplete-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 100;
    display: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    min-width: 150px;
}

.autocomplete-item {
    padding: 8px 12px;
    cursor: pointer;
}

.autocomplete-item:hover, .autocomplete-item.active {
    background: #e3f2fd;
}

.autocomplete-item.text-muted {
    color: #999;
    cursor: default;
}

.btn-type {
    padding: 5px 10px;
    border: 1px solid #ddd;
    border-radius: 3px;
    background: white;
    cursor: pointer;
    font-size: 12px;
    white-space: nowrap;
}

.btn-type:hover {
    background: #f0f0f0;
}

.btn-delete {
    padding: 5px 10px;
    border: none;
    background: none;
    cursor: pointer;
    font-size: 16px;
}

.btn-delete:hover {
    background: #fee;
    border-radius: 3px;
}

.summary {
    background: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
}

.summary p {
    margin: 5px 0;
}

.empty-state {
    text-align: center;
    padding: 50px;
    color: #666;
}

/* Saved indicator */
.saved {
    animation: flash-green 0.3s;
}

@keyframes flash-green {
    0% { background-color: #d4edda; }
    100% { background-color: transparent; }
}

/* Responsive */
@media (max-width: 1200px) {
    .edit-description { width: 120px; }
    .edit-account { width: 120px; }
    .edit-poster-account { width: 110px; }
}

@media (max-width: 900px) {
    .edit-description { width: 100px; }
    .edit-account { width: 100px; }
    .edit-poster-account { width: 90px; }
}
</style>

<script>
// Data from server
const categories = {{ categories|tojson|safe if categories else '[]' }};
const accounts = {{ accounts|tojson|safe if accounts else '[]' }};
const posterAccounts = {{ poster_accounts|tojson|safe if poster_accounts else '[]' }};
const posterTransactions = {{ poster_transactions|tojson|safe if poster_transactions else '[]' }};

console.log('Loaded categories:', categories.length, categories);
console.log('Loaded accounts:', accounts.length);
console.log('Loaded poster accounts:', posterAccounts.length);
console.log('Loaded poster transactions:', posterTransactions.length);
// Debug: show structure of first expense transaction
const firstExpense = posterTransactions.find(t => t.type == 0 || t.type == '0');
if (firstExpense) console.log('Sample expense transaction:', firstExpense);

// Map Poster system category names to human-readable names
const categoryNameMap = {
    'book_category_action_marketing': '–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥',
    'book_category_action_banking_services': '–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ —É—Å–ª—É–≥–∏ –∏ –∫–æ–º–∏—Å—Å–∏–∏',
    'book_category_action_household_expenses': '–•–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã',
    'book_category_action_rent': '–ê—Ä–µ–Ω–¥–∞',
    'book_category_action_utility_bills': '–ö–æ–º–º—É–Ω–∞–ª—å–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏',
    'book_category_action_labour_cost': '–ó–∞—Ä–ø–ª–∞—Ç–∞',
    'book_category_action_supplies': '–ü–æ—Å—Ç–∞–≤–∫–∏',
    'book_category_action_actualization': '–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è'
};

// Helper to get readable category name
function getCategoryName(cat) {
    const rawName = cat.category_name || cat.name || '';
    return categoryNameMap[rawName] || rawName;
}

let searchTimeout = null;

// Helper to find matching transactions in Poster
function findSyncStatus(amount, description, category, accountId, posterAccountId, expenseType) {
    // Find finance account name by accountId
    const financeAccount = accounts.find(a => a.account_id == accountId);
    const accountName = financeAccount ? (financeAccount.name || '').toLowerCase() : '';
    const descLower = (description || '').toLowerCase().trim();

    // Special handling for supplies - look for split supply transactions
    if (expenseType === 'supply') {
        return findSupplySyncStatus(amount, descLower, category, accountName);
    }

    // Regular transaction matching
    let bestMatch = { matches: 0, transaction: null };

    for (const t of posterTransactions) {
        // Filter by poster account if specified
        if (posterAccountId && t.poster_account_id != posterAccountId) continue;

        // Only check expenses (type 0)
        if (t.type != 0 && t.type != '0') continue;

        let matches = 0;

        // 1. Check amount
        const tAmount = parseFloat(t.amount_from) || parseFloat(t.amount) || 0;
        if (Math.abs(tAmount - amount) < 1) {
            matches++;
        }

        // 2. Check comment/description
        const tComment = (t.comment || '').toLowerCase().trim();
        if (tComment && descLower && (tComment.includes(descLower) || descLower.includes(tComment) || tComment === descLower)) {
            matches++;
        }

        // 3. Check category
        const tCategoryName = (t.category_name || '').toLowerCase();
        const catLower = (category || '').toLowerCase();
        if (tCategoryName && catLower && (tCategoryName.includes(catLower) || catLower.includes(tCategoryName))) {
            matches++;
        }

        // 4. Check account
        const tAccountName = (t.account_from_name || '').toLowerCase();
        if (accountName && tAccountName && (tAccountName.includes(accountName) || accountName.includes(tAccountName))) {
            matches++;
        }

        if (matches > bestMatch.matches) {
            bestMatch = { matches, transaction: t };
        }

        // Early exit if full match
        if (matches === 4) break;
    }

    return bestMatch.matches;
}

// Special sync status for supplies - can be split across multiple accounts
// Example: "–Ø–ø–æ—à–∞ 125000" expense might match transactions:
//   - "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññ4824 –æ—Ç ¬´–Ø–ø–æ—à–∞ ¬ª" 60000‚Ç∏ in PizzBurg
//   - "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññ4825 –æ—Ç ¬´–Ø–ø–æ—à–∞ ¬ª" 65000‚Ç∏ in PizzBurg-Cafe
// Sum = 125000‚Ç∏ = expense amount
function findSupplySyncStatus(expenseAmount, supplierName, category, accountName) {
    if (!supplierName) return 0;

    // Find all transactions that look like supply transactions with this supplier
    // Pattern: "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññxxx –æ—Ç ¬´Supplier ¬ª" or just contains supplier name
    const supplyTransactions = posterTransactions.filter(t => {
        if (t.type != 0 && t.type != '0') return false;

        const comment = (t.comment || '').toLowerCase();
        // Match "–ø–æ—Å—Ç–∞–≤–∫–∞" + supplier name
        const isSupplyComment = comment.includes('–ø–æ—Å—Ç–∞–≤–∫–∞') && comment.includes(supplierName);
        // Or direct supplier name match in comment
        const hasSupplierName = comment.includes(supplierName);

        return isSupplyComment || hasSupplierName;
    });

    if (supplyTransactions.length === 0) return 0;

    // Sum up all matching supply transaction amounts
    const totalSupplyAmount = supplyTransactions.reduce((sum, t) => {
        return sum + (parseFloat(t.amount_from) || parseFloat(t.amount) || 0);
    }, 0);

    // Check category matches
    const catLower = (category || '').toLowerCase();
    let categoryMatches = false;
    for (const t of supplyTransactions) {
        const tCategoryName = (t.category_name || '').toLowerCase();
        if (tCategoryName && catLower && (tCategoryName.includes(catLower) || catLower.includes(tCategoryName))) {
            categoryMatches = true;
            break;
        }
        // Also match if category is "–ø–æ—Å—Ç–∞–≤–∫–∞" (common for supplies)
        if (tCategoryName.includes('–ø–æ—Å—Ç–∞–≤–∫–∞') || tCategoryName.includes('—Ç–æ–≤–∞—Ä')) {
            categoryMatches = true;
            break;
        }
    }

    // Check account matches
    let accountMatches = false;
    for (const t of supplyTransactions) {
        const tAccountName = (t.account_from_name || '').toLowerCase();
        if (accountName && tAccountName && (tAccountName.includes(accountName) || accountName.includes(tAccountName))) {
            accountMatches = true;
            break;
        }
    }

    // Calculate match score
    let matches = 0;

    // 1. Amount - check if sum of supply transactions matches expense amount (with tolerance)
    if (Math.abs(totalSupplyAmount - expenseAmount) < 2) {
        matches++;
    } else if (totalSupplyAmount > 0 && Math.abs(totalSupplyAmount - expenseAmount) < expenseAmount * 0.01) {
        // 1% tolerance
        matches++;
    }

    // 2. Supplier name match (we already filtered by this, so it's a match)
    matches++;

    // 3. Category
    if (categoryMatches) matches++;

    // 4. Account
    if (accountMatches) matches++;

    return matches;
}

// Update row sync status
function updateRowSyncStatus(row) {
    const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
    const description = row.querySelector('.edit-description').value;
    const category = row.querySelector('.edit-category').value;
    const accountSelect = row.querySelector('.edit-account');
    const accountId = accountSelect ? accountSelect.value : null;
    const posterAccountSelect = row.querySelector('.edit-poster-account');
    const posterAccountId = posterAccountSelect ? posterAccountSelect.value : null;

    // Get expense type from the type button
    const typeBtn = row.querySelector('.btn-type');
    const expenseType = typeBtn ? typeBtn.dataset.type : 'transaction';

    const matches = findSyncStatus(amount, description, category, accountId, posterAccountId, expenseType);

    // Debug: log first few rows
    if (amount > 1000) {
        console.log(`Sync check: ${amount}‚Ç∏ "${description}" cat="${category}" => ${matches} matches`);
    }

    row.classList.remove('sync-full', 'sync-partial');
    if (matches >= 4) {
        row.classList.add('sync-full');
    } else if (matches >= 3) {
        row.classList.add('sync-partial');
    }
}

// Update all rows sync status
function updateAllSyncStatus() {
    document.querySelectorAll('.draft-row').forEach(row => {
        updateRowSyncStatus(row);
    });
}

document.addEventListener('DOMContentLoaded', function() {
    // Initial sync status check
    updateAllSyncStatus();

    // Select all checkbox
    const selectAll = document.getElementById('select-all');
    const countSpan = document.getElementById('count');

    function updateCount() {
        const checked = document.querySelectorAll('.draft-checkbox:checked').length;
        countSpan.textContent = checked;
    }

    function updateSummary() {
        const rows = document.querySelectorAll('.draft-row');
        let total = 0;
        let transactions = 0;
        let supplies = 0;

        rows.forEach(row => {
            const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
            total += amount;
            if (row.classList.contains('supply')) {
                supplies++;
            } else {
                transactions++;
            }
        });

        document.getElementById('total-count').textContent = rows.length;
        document.getElementById('transaction-count').textContent = transactions;
        document.getElementById('supply-count').textContent = supplies;
        document.getElementById('total-sum').textContent = total.toLocaleString('ru-RU');
    }

    if (selectAll) {
        selectAll.addEventListener('change', function() {
            document.querySelectorAll('.draft-checkbox').forEach(cb => cb.checked = this.checked);
            updateCount();
        });
    }

    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('draft-checkbox')) {
            updateCount();
        }
    });

    // Add new row button
    document.getElementById('add-row-btn').addEventListener('click', async function() {
        await addNewRow();
    });

    // Add empty row at the bottom initially
    ensureEmptyRow();

    // Toggle type buttons - use event delegation
    document.addEventListener('click', async function(e) {
        if (e.target.classList.contains('btn-type')) {
            const btn = e.target;
            const id = btn.dataset.id;
            const currentType = btn.dataset.type;
            const newType = currentType === 'supply' ? 'transaction' : 'supply';

            try {
                const response = await fetch(`/expenses/toggle-type/${id}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({expense_type: newType})
                });

                if (response.ok) {
                    btn.dataset.type = newType;
                    btn.innerHTML = newType === 'supply' ? 'üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞' : 'üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è';

                    const row = btn.closest('tr');
                    row.classList.remove('supply', 'transaction');
                    row.classList.add(newType);
                    updateSummary();
                }
            } catch (e) {
                console.error('Error:', e);
            }
        }

        // Delete button
        if (e.target.classList.contains('btn-delete')) {
            if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —á–µ—Ä–Ω–æ–≤–∏–∫?')) return;

            const id = e.target.dataset.id;
            try {
                const response = await fetch(`/expenses/delete/${id}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    e.target.closest('tr').remove();
                    updateSummary();
                }
            } catch (err) {
                console.error('Error:', err);
            }
        }

        // Completion status toggle: pending ‚Üí partial ‚Üí completed ‚Üí pending
        if (e.target.classList.contains('btn-completion')) {
            const btn = e.target;
            const id = btn.dataset.id;
            const currentStatus = btn.dataset.status || 'pending';

            // Cycle through statuses
            const nextStatus = currentStatus === 'pending' ? 'partial' :
                              currentStatus === 'partial' ? 'completed' : 'pending';
            const statusIcons = { pending: '‚ö™', partial: 'üü°', completed: '‚úÖ' };

            try {
                const response = await fetch(`/expenses/update/${id}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ completion_status: nextStatus })
                });

                if (response.ok) {
                    btn.dataset.status = nextStatus;
                    btn.textContent = statusIcons[nextStatus];

                    const row = btn.closest('tr');
                    row.classList.remove('pending', 'partial', 'completed');
                    row.classList.add(nextStatus);
                    row.dataset.completionStatus = nextStatus;
                }
            } catch (err) {
                console.error('Error:', err);
            }
        }
    });

    // Auto-select '0' on focus for amount fields
    document.addEventListener('focus', function(e) {
        if (e.target.classList.contains('edit-amount')) {
            const input = e.target;
            if (input.value === '0' || input.value === '') {
                setTimeout(() => input.select(), 10);
            }
        }
    }, true);

    // Detect when user fills an empty row -> ensure new empty row exists
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('edit-amount') || e.target.classList.contains('edit-description')) {
            const row = e.target.closest('tr');
            const tbody = row?.parentElement;
            if (!tbody) return;

            // Check if this is the last row
            const rows = tbody.querySelectorAll('.draft-row');
            if (rows.length > 0 && rows[rows.length - 1] === row) {
                // User is filling the last row, ensure there's a new empty row
                ensureEmptyRow();
            }
        }
    });

    // Amount editing - use event delegation
    document.addEventListener('change', async function(e) {
        if (e.target.classList.contains('edit-amount')) {
            const input = e.target;
            const id = input.dataset.id;
            await updateField(id, 'amount', input.value);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateSummary();
            updateRowSyncStatus(input.closest('tr'));
        }

        // Description editing
        if (e.target.classList.contains('edit-description')) {
            const input = e.target;
            const id = input.dataset.id;
            await updateField(id, 'description', input.value);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateRowSyncStatus(input.closest('tr'));
        }

        // Account select
        if (e.target.classList.contains('edit-account')) {
            const select = e.target;
            const id = select.dataset.id;
            await updateField(id, 'account_id', select.value);
            select.classList.add('saved');
            setTimeout(() => select.classList.remove('saved'), 300);
            updateRowSyncStatus(select.closest('tr'));
        }

        // Poster account select
        if (e.target.classList.contains('edit-poster-account')) {
            const select = e.target;
            const id = select.dataset.id;
            const posterAccountId = select.value;
            await updateField(id, 'poster_account_id', posterAccountId);
            select.classList.add('saved');
            setTimeout(() => select.classList.remove('saved'), 300);

            // Update finance accounts dropdown to show only accounts from selected poster account
            const row = select.closest('tr');
            const accountSelect = row.querySelector('.edit-account');
            if (accountSelect) {
                const currentValue = accountSelect.value;
                accountSelect.innerHTML = '';
                accounts.forEach(acc => {
                    if (acc.poster_account_id == posterAccountId) {
                        const option = document.createElement('option');
                        option.value = acc.account_id;
                        option.textContent = acc.name;
                        option.dataset.name = (acc.name || '').toLowerCase();
                        option.dataset.posterAccountId = acc.poster_account_id;
                        if (acc.account_id == currentValue) {
                            option.selected = true;
                        }
                        accountSelect.appendChild(option);
                    }
                });
                // If no match, select first
                if (!accountSelect.value && accountSelect.options.length > 0) {
                    accountSelect.selectedIndex = 0;
                    await updateField(id, 'account_id', accountSelect.value);
                }
            }
            updateRowSyncStatus(row);
        }
    });

    // Category autocomplete - use event delegation
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;

            clearTimeout(searchTimeout);
            const query = input.value.toLowerCase().trim();

            if (query.length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }

            // Get selected poster account to filter categories
            const row = input.closest('tr');
            const posterAccountSelect = row?.querySelector('.edit-poster-account');
            const selectedPosterAccountId = posterAccountSelect ? parseInt(posterAccountSelect.value) : null;

            searchTimeout = setTimeout(() => {
                // Find ALL matching categories (don't strictly filter by department)
                let matches = categories.filter(c => {
                    const displayName = getCategoryName(c);
                    return displayName.toLowerCase().includes(query);
                });

                // Sort: selected department first, then alphabetically
                matches.sort((a, b) => {
                    const aMatch = a.poster_account_id == selectedPosterAccountId ? 0 : 1;
                    const bMatch = b.poster_account_id == selectedPosterAccountId ? 0 : 1;
                    if (aMatch !== bMatch) return aMatch - bMatch;
                    const aName = getCategoryName(a).toLowerCase();
                    const bName = getCategoryName(b).toLowerCase();
                    return aName.localeCompare(bName);
                });

                // Deduplicate by display name (keep first, which is from selected department)
                const seen = new Set();
                matches = matches.filter(c => {
                    const displayName = getCategoryName(c).toLowerCase();
                    if (seen.has(displayName)) return false;
                    seen.add(displayName);
                    return true;
                }).slice(0, 10);

                if (matches.length === 0) {
                    resultsDiv.innerHTML = `<div class="autocomplete-item" data-name="${input.value}">‚ûï –î–æ–±–∞–≤–∏—Ç—å "${input.value}"</div>`;
                } else {
                    resultsDiv.innerHTML = matches.map((c, i) => {
                        const displayName = getCategoryName(c);
                        const isOtherDept = selectedPosterAccountId && c.poster_account_id && c.poster_account_id != selectedPosterAccountId;
                        const accountTag = isOtherDept && c.poster_account_name ? ` <small style="color:#999">(${c.poster_account_name})</small>` : '';
                        return `<div class="autocomplete-item" data-name="${displayName}" data-index="${i}">${displayName}${accountTag}</div>`;
                    }).join('');
                }
                resultsDiv.style.display = 'block';
            }, 100);
        }
    });

    // Category autocomplete click
    document.addEventListener('click', async function(e) {
        if (e.target.classList.contains('autocomplete-item')) {
            const item = e.target;
            const wrapper = item.closest('.autocomplete-wrapper');
            const input = wrapper.querySelector('.edit-category');
            const resultsDiv = wrapper.querySelector('.autocomplete-results');

            const name = item.dataset.name;
            input.value = name;
            resultsDiv.style.display = 'none';

            const id = input.dataset.id;
            await updateField(id, 'category', name);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateRowSyncStatus(input.closest('tr'));
        }
    });

    // Category blur - save and close
    document.addEventListener('blur', async function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;

            setTimeout(async () => {
                resultsDiv.style.display = 'none';
                // Save value
                const id = input.dataset.id;
                await updateField(id, 'category', input.value);
                updateRowSyncStatus(input.closest('tr'));
            }, 200);
        }
    }, true);

    // Category keyboard navigation
    document.addEventListener('keydown', function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;
            const items = resultsDiv.querySelectorAll('.autocomplete-item');

            if (items.length === 0) return;

            let selectedIndex = Array.from(items).findIndex(item => item.classList.contains('active'));

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                items.forEach((item, i) => item.classList.toggle('active', i === selectedIndex));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, 0);
                items.forEach((item, i) => item.classList.toggle('active', i === selectedIndex));
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                if (selectedIndex >= 0 && items[selectedIndex]) {
                    e.preventDefault();
                    items[selectedIndex].click();
                } else if (items.length === 1) {
                    e.preventDefault();
                    items[0].click();
                }
            } else if (e.key === 'Escape') {
                resultsDiv.style.display = 'none';
            }
        }
    });
});

async function updateField(id, field, value) {
    try {
        const data = {};
        data[field] = value;

        await fetch(`/expenses/update/${id}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
    } catch (e) {
        console.error('Error updating field:', e);
    }
}

// Create new row dynamically
async function addNewRow(focusAmount = true) {
    try {
        const response = await fetch('/expenses/create', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({})
        });

        const result = await response.json();
        if (result.success) {
            const newRow = createRowElement(result.draft);
            const tbody = document.getElementById('drafts-tbody');
            tbody.appendChild(newRow);

            if (focusAmount) {
                const amountInput = newRow.querySelector('.edit-amount');
                if (amountInput) amountInput.focus();
            }

            updateSummaryGlobal();
            return newRow;
        } else {
            console.error('Error creating row:', result.error);
            return null;
        }
    } catch (e) {
        console.error('Error:', e);
        return null;
    }
}

// Ensure there's always an empty row at the bottom
function ensureEmptyRow() {
    const tbody = document.getElementById('drafts-tbody');
    if (!tbody) return;

    // Check if last row is empty (amount = 0 and description empty)
    const rows = tbody.querySelectorAll('.draft-row');
    if (rows.length > 0) {
        const lastRow = rows[rows.length - 1];
        const amount = parseFloat(lastRow.querySelector('.edit-amount')?.value) || 0;
        const desc = lastRow.querySelector('.edit-description')?.value?.trim() || '';

        if (amount === 0 && desc === '') {
            // Last row is already empty
            return;
        }
    }

    // Add new empty row
    addNewRow(false);
}

// Create row element from draft data
function createRowElement(draft) {
    const tr = document.createElement('tr');
    const completionStatus = draft.completion_status || 'pending';
    tr.className = 'draft-row ' + (draft.expense_type === 'supply' ? 'supply' : 'transaction') + ' ' + completionStatus;
    tr.dataset.id = draft.id;
    tr.dataset.amount = draft.amount || 0;
    tr.dataset.description = draft.description || '';
    tr.dataset.category = draft.category || '';
    tr.dataset.accountId = draft.account_id || '';
    tr.dataset.posterAccountId = draft.poster_account_id || '';
    tr.dataset.completionStatus = completionStatus;

    // Build accounts options - filtered by poster_account_id or show all if not set
    let accountOptions = '';
    const posterAccId = draft.poster_account_id || (posterAccounts.length > 0 ? posterAccounts.find(p => p.is_primary)?.id : null);
    accounts.forEach(acc => {
        if (!posterAccId || acc.poster_account_id == posterAccId) {
            const selected = acc.account_id == draft.account_id ? 'selected' : '';
            accountOptions += `<option value="${acc.account_id}" data-name="${(acc.name||'').toLowerCase()}" data-poster-account-id="${acc.poster_account_id}" ${selected}>${acc.name}</option>`;
        }
    });

    // Build poster accounts options
    let posterAccountOptions = '';
    posterAccounts.forEach(pa => {
        const selected = pa.id == draft.poster_account_id || (!draft.poster_account_id && pa.is_primary) ? 'selected' : '';
        posterAccountOptions += `<option value="${pa.id}" ${selected}>${pa.name}</option>`;
    });

    // Completion status icon
    const statusIcons = { pending: '‚ö™', partial: 'üü°', completed: '‚úÖ' };
    const statusIcon = statusIcons[completionStatus] || '‚ö™';

    tr.innerHTML = `
        <td>
            <input type="checkbox" name="draft_ids" value="${draft.id}" class="draft-checkbox">
        </td>
        <td class="completion-status">
            <button type="button" class="btn-completion" data-id="${draft.id}" data-status="${completionStatus}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                ${statusIcon}
            </button>
        </td>
        <td class="amount">
            <input type="number" class="edit-amount" value="${draft.amount || 0}"
                   data-id="${draft.id}" step="1" min="0">
        </td>
        <td class="description">
            <input type="text" class="edit-description" value="${draft.description || ''}"
                   data-id="${draft.id}">
        </td>
        <td class="type">
            <button type="button" class="btn-type"
                    data-id="${draft.id}"
                    data-type="${draft.expense_type || 'transaction'}">
                ${draft.expense_type === 'supply' ? 'üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞' : 'üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è'}
            </button>
        </td>
        <td class="category">
            <div class="autocomplete-wrapper">
                <input type="text" class="edit-category"
                       value="${draft.category || ''}"
                       data-id="${draft.id}"
                       placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                       autocomplete="off">
                <div class="autocomplete-results"></div>
            </div>
        </td>
        <td class="account">
            <select class="edit-account" data-id="${draft.id}" data-source="${draft.source || ''}" data-poster-account-id="${draft.poster_account_id || ''}">
                ${accountOptions}
            </select>
        </td>
        <td class="poster-account">
            <select class="edit-poster-account" data-id="${draft.id}">
                ${posterAccountOptions}
            </select>
        </td>
        <td class="actions">
            <button type="button" class="btn-delete" data-id="${draft.id}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
        </td>
    `;

    return tr;
}

function updateSummaryGlobal() {
    const rows = document.querySelectorAll('.draft-row');
    let total = 0;
    let transactions = 0;
    let supplies = 0;

    rows.forEach(row => {
        const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
        total += amount;
        if (row.classList.contains('supply')) {
            supplies++;
        } else {
            transactions++;
        }
    });

    document.getElementById('total-count').textContent = rows.length;
    document.getElementById('transaction-count').textContent = transactions;
    document.getElementById('supply-count').textContent = supplies;
    document.getElementById('total-sum').textContent = total.toLocaleString('ru-RU');
}
</script>
{% endblock %}
