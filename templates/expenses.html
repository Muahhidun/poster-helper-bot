{% extends "base.html" %}

{% block title %}–†–∞—Å—Ö–æ–¥—ã - PizzBurg{% endblock %}

{% block content %}
<div class="container">
    <h1>–ß–µ—Ä–Ω–æ–≤–∏–∫–∏ —Ä–∞—Å—Ö–æ–¥–æ–≤</h1>

    <form id="drafts-form" method="POST">
        <div class="drafts-actions">
            <button type="submit" formaction="{{ url_for('process_drafts') }}" class="btn btn-success">
                ‚úÖ –°–æ–∑–¥–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            </button>
            <button type="submit" formaction="{{ url_for('delete_drafts') }}" class="btn btn-danger"
                    onclick="return confirm('–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ?')">
                üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ
            </button>
            <span class="selected-count">–í—ã–±—Ä–∞–Ω–æ: <span id="count">0</span></span>
        </div>

        <div class="sync-legend">
            <span class="legend-item"><span class="dot green"></span> –°–æ–≤–ø–∞–ª–æ 4/4 (—É–∂–µ –≤ Poster)</span>
            <span class="legend-item"><span class="dot yellow"></span> –°–æ–≤–ø–∞–ª–æ 3/4 (—á–∞—Å—Ç–∏—á–Ω–æ–µ)</span>
            <span class="legend-item"><span class="dot none"></span> –ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤ Poster</span>
        </div>

        <!-- Section: –ù–∞–ª–∏—á–∫–∞ (Cash) -->
        <div class="account-section" data-account-type="cash">
            <h2 class="section-header">üíµ –ù–∞–ª–∏—á–∫–∞</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th style="width:40px"><input type="checkbox" class="select-all-section" data-section="cash"></th>
                        <th style="width:40px">‚úì</th>
                        <th class="sortable" data-sort="amount" data-section="cash">–°—É–º–º–∞ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="description" data-section="cash">–û–ø–∏—Å–∞–Ω–∏–µ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="type" data-section="cash">–¢–∏–ø <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="category" data-section="cash">–ö–∞—Ç–µ–≥–æ—Ä–∏—è <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="department" data-section="cash">–û—Ç–¥–µ–ª <span class="sort-icon">‚Üï</span></th>
                        <th style="width:40px"></th>
                    </tr>
                </thead>
                <tbody id="drafts-tbody-cash" data-account-type="cash">
                    {% for draft in drafts %}
                    {% set ns = namespace(account_name='') %}
                    {% for acc in accounts if acc.account_id == draft.account_id %}
                        {% set ns.account_name = acc.name|lower %}
                    {% endfor %}
                    {% if 'kaspi' not in (ns.account_name or draft.source|default('')|lower) and '—Ö–∞–ª—ã–∫' not in ns.account_name and 'halyk' not in ns.account_name %}
                    <tr class="draft-row {% if draft.expense_type == 'supply' %}supply{% else %}transaction{% endif %} {% if draft.completion_status == 'completed' %}completed{% elif draft.completion_status == 'partial' %}partial{% endif %}"
                        data-id="{{ draft.id }}"
                        data-amount="{{ draft.amount|int }}"
                        data-description="{{ draft.description }}"
                        data-category="{{ draft.category or '' }}"
                        data-account-id="{{ draft.account_id or '' }}"
                        data-poster-account-id="{{ draft.poster_account_id or '' }}"
                        data-completion-status="{{ draft.completion_status or 'pending' }}"
                        data-account-type="cash">
                        <td>
                            <input type="checkbox" name="draft_ids" value="{{ draft.id }}" class="draft-checkbox">
                        </td>
                        <td class="completion-status">
                            <button type="button" class="btn-completion" data-id="{{ draft.id }}" data-status="{{ draft.completion_status or 'pending' }}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                                {% if draft.completion_status == 'completed' %}‚úÖ
                                {% elif draft.completion_status == 'partial' %}üü°
                                {% else %}‚ö™{% endif %}
                            </button>
                        </td>
                        <td class="amount">
                            <input type="number" class="edit-amount" value="{{ draft.amount|int }}"
                                   data-id="{{ draft.id }}" step="1" min="0">
                        </td>
                        <td class="description">
                            <input type="text" class="edit-description" value="{{ draft.description }}"
                                   data-id="{{ draft.id }}">
                        </td>
                        <td class="type">
                            <button type="button" class="btn-type"
                                    data-id="{{ draft.id }}"
                                    data-type="{{ draft.expense_type }}">
                                {% if draft.expense_type == 'supply' %}
                                    üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞
                                {% else %}
                                    üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
                                {% endif %}
                            </button>
                        </td>
                        <td class="category">
                            <div class="autocomplete-wrapper">
                                <input type="text" class="edit-category"
                                       value="{{ draft.category or '' }}"
                                       data-id="{{ draft.id }}"
                                       placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                                       autocomplete="off">
                                <div class="autocomplete-results"></div>
                            </div>
                        </td>
                        <td class="poster-account">
                            <select class="edit-poster-account" data-id="{{ draft.id }}">
                                {% for pa in poster_accounts %}
                                <option value="{{ pa.id }}"
                                        {% if draft.poster_account_id == pa.id %}selected
                                        {% elif not draft.poster_account_id and pa.is_primary %}selected
                                        {% endif %}>
                                    {{ pa.name }}
                                </option>
                                {% endfor %}
                            </select>
                        </td>
                        <td class="actions">
                            <button type="button" class="btn-delete" data-id="{{ draft.id }}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
                        </td>
                    </tr>
                    {% endif %}
                    {% endfor %}
                </tbody>
            </table>
            <div class="section-summary" id="summary-cash">
                <span class="sum">0‚Ç∏</span>
            </div>
        </div>

        <!-- Section: Kaspi Pay -->
        <div class="account-section" data-account-type="kaspi">
            <h2 class="section-header">üì± Kaspi Pay</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th style="width:40px"><input type="checkbox" class="select-all-section" data-section="kaspi"></th>
                        <th style="width:40px">‚úì</th>
                        <th class="sortable" data-sort="amount" data-section="kaspi">–°—É–º–º–∞ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="description" data-section="kaspi">–û–ø–∏—Å–∞–Ω–∏–µ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="type" data-section="kaspi">–¢–∏–ø <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="category" data-section="kaspi">–ö–∞—Ç–µ–≥–æ—Ä–∏—è <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="department" data-section="kaspi">–û—Ç–¥–µ–ª <span class="sort-icon">‚Üï</span></th>
                        <th style="width:40px"></th>
                    </tr>
                </thead>
                <tbody id="drafts-tbody-kaspi" data-account-type="kaspi">
                    {% for draft in drafts %}
                    {% set ns = namespace(account_name='') %}
                    {% for acc in accounts if acc.account_id == draft.account_id %}
                        {% set ns.account_name = acc.name|lower %}
                    {% endfor %}
                    {% if 'kaspi' in (ns.account_name or draft.source|default('')|lower) %}
                    <tr class="draft-row {% if draft.expense_type == 'supply' %}supply{% else %}transaction{% endif %} {% if draft.completion_status == 'completed' %}completed{% elif draft.completion_status == 'partial' %}partial{% endif %}"
                        data-id="{{ draft.id }}"
                        data-amount="{{ draft.amount|int }}"
                        data-description="{{ draft.description }}"
                        data-category="{{ draft.category or '' }}"
                        data-account-id="{{ draft.account_id or '' }}"
                        data-poster-account-id="{{ draft.poster_account_id or '' }}"
                        data-completion-status="{{ draft.completion_status or 'pending' }}"
                        data-account-type="kaspi">
                        <td>
                            <input type="checkbox" name="draft_ids" value="{{ draft.id }}" class="draft-checkbox">
                        </td>
                        <td class="completion-status">
                            <button type="button" class="btn-completion" data-id="{{ draft.id }}" data-status="{{ draft.completion_status or 'pending' }}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                                {% if draft.completion_status == 'completed' %}‚úÖ
                                {% elif draft.completion_status == 'partial' %}üü°
                                {% else %}‚ö™{% endif %}
                            </button>
                        </td>
                        <td class="amount">
                            <input type="number" class="edit-amount" value="{{ draft.amount|int }}"
                                   data-id="{{ draft.id }}" step="1" min="0">
                        </td>
                        <td class="description">
                            <input type="text" class="edit-description" value="{{ draft.description }}"
                                   data-id="{{ draft.id }}">
                        </td>
                        <td class="type">
                            <button type="button" class="btn-type"
                                    data-id="{{ draft.id }}"
                                    data-type="{{ draft.expense_type }}">
                                {% if draft.expense_type == 'supply' %}
                                    üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞
                                {% else %}
                                    üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
                                {% endif %}
                            </button>
                        </td>
                        <td class="category">
                            <div class="autocomplete-wrapper">
                                <input type="text" class="edit-category"
                                       value="{{ draft.category or '' }}"
                                       data-id="{{ draft.id }}"
                                       placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                                       autocomplete="off">
                                <div class="autocomplete-results"></div>
                            </div>
                        </td>
                        <td class="poster-account">
                            <select class="edit-poster-account" data-id="{{ draft.id }}">
                                {% for pa in poster_accounts %}
                                <option value="{{ pa.id }}"
                                        {% if draft.poster_account_id == pa.id %}selected
                                        {% elif not draft.poster_account_id and pa.is_primary %}selected
                                        {% endif %}>
                                    {{ pa.name }}
                                </option>
                                {% endfor %}
                            </select>
                        </td>
                        <td class="actions">
                            <button type="button" class="btn-delete" data-id="{{ draft.id }}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
                        </td>
                    </tr>
                    {% endif %}
                    {% endfor %}
                </tbody>
            </table>
            <div class="section-summary" id="summary-kaspi">
                <span class="sum">0‚Ç∏</span>
            </div>
        </div>

        <!-- Section: –•–∞–ª—ã–∫ -->
        <div class="account-section" data-account-type="halyk">
            <h2 class="section-header">üè¶ –•–∞–ª—ã–∫</h2>
            <table class="table">
                <thead>
                    <tr>
                        <th style="width:40px"><input type="checkbox" class="select-all-section" data-section="halyk"></th>
                        <th style="width:40px">‚úì</th>
                        <th class="sortable" data-sort="amount" data-section="halyk">–°—É–º–º–∞ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="description" data-section="halyk">–û–ø–∏—Å–∞–Ω–∏–µ <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="type" data-section="halyk">–¢–∏–ø <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="category" data-section="halyk">–ö–∞—Ç–µ–≥–æ—Ä–∏—è <span class="sort-icon">‚Üï</span></th>
                        <th class="sortable" data-sort="department" data-section="halyk">–û—Ç–¥–µ–ª <span class="sort-icon">‚Üï</span></th>
                        <th style="width:40px"></th>
                    </tr>
                </thead>
                <tbody id="drafts-tbody-halyk" data-account-type="halyk">
                    {% for draft in drafts %}
                    {% set ns = namespace(account_name='') %}
                    {% for acc in accounts if acc.account_id == draft.account_id %}
                        {% set ns.account_name = acc.name|lower %}
                    {% endfor %}
                    {% if '—Ö–∞–ª—ã–∫' in ns.account_name or 'halyk' in ns.account_name %}
                    <tr class="draft-row {% if draft.expense_type == 'supply' %}supply{% else %}transaction{% endif %} {% if draft.completion_status == 'completed' %}completed{% elif draft.completion_status == 'partial' %}partial{% endif %}"
                        data-id="{{ draft.id }}"
                        data-amount="{{ draft.amount|int }}"
                        data-description="{{ draft.description }}"
                        data-category="{{ draft.category or '' }}"
                        data-account-id="{{ draft.account_id or '' }}"
                        data-poster-account-id="{{ draft.poster_account_id or '' }}"
                        data-completion-status="{{ draft.completion_status or 'pending' }}"
                        data-account-type="halyk">
                        <td>
                            <input type="checkbox" name="draft_ids" value="{{ draft.id }}" class="draft-checkbox">
                        </td>
                        <td class="completion-status">
                            <button type="button" class="btn-completion" data-id="{{ draft.id }}" data-status="{{ draft.completion_status or 'pending' }}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                                {% if draft.completion_status == 'completed' %}‚úÖ
                                {% elif draft.completion_status == 'partial' %}üü°
                                {% else %}‚ö™{% endif %}
                            </button>
                        </td>
                        <td class="amount">
                            <input type="number" class="edit-amount" value="{{ draft.amount|int }}"
                                   data-id="{{ draft.id }}" step="1" min="0">
                        </td>
                        <td class="description">
                            <input type="text" class="edit-description" value="{{ draft.description }}"
                                   data-id="{{ draft.id }}">
                        </td>
                        <td class="type">
                            <button type="button" class="btn-type"
                                    data-id="{{ draft.id }}"
                                    data-type="{{ draft.expense_type }}">
                                {% if draft.expense_type == 'supply' %}
                                    üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞
                                {% else %}
                                    üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è
                                {% endif %}
                            </button>
                        </td>
                        <td class="category">
                            <div class="autocomplete-wrapper">
                                <input type="text" class="edit-category"
                                       value="{{ draft.category or '' }}"
                                       data-id="{{ draft.id }}"
                                       placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                                       autocomplete="off">
                                <div class="autocomplete-results"></div>
                            </div>
                        </td>
                        <td class="poster-account">
                            <select class="edit-poster-account" data-id="{{ draft.id }}">
                                {% for pa in poster_accounts %}
                                <option value="{{ pa.id }}"
                                        {% if draft.poster_account_id == pa.id %}selected
                                        {% elif not draft.poster_account_id and pa.is_primary %}selected
                                        {% endif %}>
                                    {{ pa.name }}
                                </option>
                                {% endfor %}
                            </select>
                        </td>
                        <td class="actions">
                            <button type="button" class="btn-delete" data-id="{{ draft.id }}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
                        </td>
                    </tr>
                    {% endif %}
                    {% endfor %}
                </tbody>
            </table>
            <div class="section-summary" id="summary-halyk">
                <span class="sum">0‚Ç∏</span>
            </div>
        </div>

        <div class="summary">
            <p>–í—Å–µ–≥–æ: <span id="total-count">{{ drafts|length }}</span> –∑–∞–ø–∏—Å–µ–π</p>
            <p>üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: <span id="transaction-count">{{ drafts|selectattr('expense_type', 'equalto', 'transaction')|list|length }}</span></p>
            <p>üì¶ –ü–æ—Å—Ç–∞–≤–æ–∫: <span id="supply-count">{{ drafts|selectattr('expense_type', 'equalto', 'supply')|list|length }}</span></p>
            <p><strong>–û–±—â–∞—è —Å—É–º–º–∞: <span id="total-sum">{{ "{:,.0f}".format(drafts|sum(attribute='amount')) }}</span>‚Ç∏</strong></p>
        </div>
    </form>

    {% if not drafts %}
    <div class="empty-state">
        <p>–ù–µ—Ç —á–µ—Ä–Ω–æ–≤–∏–∫–æ–≤ —Ä–∞—Å—Ö–æ–¥–æ–≤</p>
        <p>–î–æ–±–∞–≤—å—Ç–µ —Ä–∞—Å—Ö–æ–¥ –≤ –Ω—É–∂–Ω—É—é —Å–µ–∫—Ü–∏—é –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/Kaspi –≤—ã–ø–∏—Å–∫—É –≤ –±–æ—Ç–∞.</p>
    </div>
    {% endif %}
</div>

<style>
/* Modern Notion-like Design */
:root {
    --bg-primary: #ffffff;
    --bg-secondary: #f7f7f5;
    --bg-hover: #f1f1ef;
    --border-color: #e9e9e7;
    --text-primary: #37352f;
    --text-secondary: #6b6b6b;
    --text-muted: #9b9b9b;
    --accent-green: #0f7b6c;
    --accent-orange: #d9730d;
    --accent-blue: #0b6bcb;
    --accent-red: #e03e3e;
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
    --radius-sm: 4px;
    --radius-md: 6px;
    --radius-lg: 8px;
}

* {
    box-sizing: border-box;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    padding: 24px 32px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    color: var(--text-primary);
}

h1 {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 24px;
    letter-spacing: -0.02em;
}

/* Action buttons */
.drafts-actions {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    align-items: center;
    flex-wrap: wrap;
}

.btn {
    padding: 8px 16px;
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.15s ease;
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.btn-success {
    background: var(--accent-green);
    color: white;
}

.btn-success:hover {
    background: #0a6b5f;
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.btn-danger {
    background: #fef2f2;
    color: var(--accent-red);
    border: 1px solid #fecaca;
}

.btn-danger:hover {
    background: #fee2e2;
    border-color: var(--accent-red);
    color: #b91c1c;
}

.selected-count {
    margin-left: auto;
    font-size: 13px;
    color: var(--text-secondary);
    font-weight: 500;
}

/* Sync legend */
.sync-legend {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    font-size: 12px;
    color: var(--text-secondary);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.dot.green { background: var(--accent-green); }
.dot.yellow { background: var(--accent-orange); }
.dot.none { background: var(--border-color); }

/* Account sections */
.account-section {
    margin-bottom: 24px;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    overflow: hidden;
    box-shadow: var(--shadow-sm);
}

.section-header {
    margin: 0;
    padding: 14px 20px;
    font-size: 15px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px solid var(--border-color);
}

.account-section[data-account-type="cash"] .section-header {
    background: linear-gradient(to right, #ecfdf5, #f0fdf4);
    color: var(--accent-green);
}

.account-section[data-account-type="kaspi"] .section-header {
    background: linear-gradient(to right, #fff7ed, #fffbeb);
    color: var(--accent-orange);
}

.account-section[data-account-type="halyk"] .section-header {
    background: linear-gradient(to right, #eff6ff, #f0f9ff);
    color: var(--accent-blue);
}

/* Table styles */
.table {
    width: 100%;
    border-collapse: collapse;
}

.table th {
    padding: 10px 12px;
    text-align: left;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border-color);
    white-space: nowrap;
    position: relative;
    user-select: none;
}

/* Sortable headers */
.table th.sortable {
    cursor: pointer;
    transition: background 0.15s;
}

.table th.sortable:hover {
    background: var(--bg-hover);
}

.table th .sort-icon {
    margin-left: 4px;
    opacity: 0.4;
    font-size: 10px;
}

.table th.sort-asc .sort-icon,
.table th.sort-desc .sort-icon {
    opacity: 1;
}

.table td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border-color);
    vertical-align: middle;
}

.draft-row {
    transition: background 0.1s;
}

.draft-row:hover {
    background: var(--bg-hover);
}

.draft-row:last-child td {
    border-bottom: none;
}

/* Row type indicators */
.draft-row.supply td:first-child {
    box-shadow: inset 3px 0 0 var(--accent-blue);
}

.draft-row.transaction td:first-child {
    box-shadow: inset 3px 0 0 var(--accent-green);
}

/* Status styles */
.draft-row.sync-full {
    background: #f0fdf4 !important;
}

.draft-row.sync-partial {
    background: #fffbeb !important;
}

.draft-row.partial {
    background: #fffbeb !important;
}

.draft-row.completed {
    background: #f0fdf4 !important;
    opacity: 0.7;
}

/* Editable inputs - with visible borders */
.edit-amount,
.edit-description,
.edit-category {
    width: 100%;
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    background: white;
    font-size: 14px;
    color: var(--text-primary);
    transition: all 0.15s;
}

.edit-amount {
    width: 100px;
    text-align: right;
    font-variant-numeric: tabular-nums;
    font-weight: 600;
}

.edit-description {
    width: 180px;
}

.edit-category {
    width: 140px;
}

.edit-amount:hover,
.edit-description:hover,
.edit-category:hover {
    border-color: #d1d5db;
    background: #fafafa;
}

.edit-amount:focus,
.edit-description:focus,
.edit-category:focus {
    outline: none;
    background: white;
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 3px rgba(11, 107, 203, 0.1);
}

/* Select dropdown */
.edit-poster-account {
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    background: white;
    font-size: 14px;
    color: var(--text-primary);
    cursor: pointer;
    min-width: 120px;
}

.edit-poster-account:hover {
    border-color: #d1d5db;
    background: #fafafa;
}

.edit-poster-account:focus {
    outline: none;
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 3px rgba(11, 107, 203, 0.1);
}

/* Completion button */
.btn-completion {
    border: none;
    background: none;
    font-size: 18px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: var(--radius-sm);
    transition: transform 0.1s;
}

.btn-completion:hover {
    background: var(--bg-hover);
    transform: scale(1.1);
}

/* Type button */
.btn-type {
    padding: 4px 10px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: white;
    cursor: pointer;
    font-size: 12px;
    white-space: nowrap;
    transition: all 0.15s;
}

.btn-type:hover {
    background: var(--bg-secondary);
    border-color: var(--text-muted);
}

/* Delete button */
.btn-delete {
    padding: 6px 8px;
    border: none;
    background: none;
    cursor: pointer;
    font-size: 14px;
    opacity: 0.4;
    transition: all 0.15s;
    border-radius: var(--radius-sm);
}

.draft-row:hover .btn-delete {
    opacity: 1;
}

.btn-delete:hover {
    background: #fef2f2;
    color: var(--accent-red);
}

/* Autocomplete */
.autocomplete-wrapper {
    position: relative;
}

.autocomplete-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    max-height: 240px;
    overflow-y: auto;
    z-index: 100;
    display: none;
    box-shadow: var(--shadow-md);
    min-width: 180px;
}

.autocomplete-item {
    padding: 10px 14px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.1s;
}

.autocomplete-item:hover,
.autocomplete-item.active {
    background: var(--bg-hover);
}

/* Section summary */
.section-summary {
    padding: 12px 20px;
    background: var(--bg-secondary);
    text-align: right;
    font-weight: 600;
    font-size: 14px;
    color: var(--text-secondary);
}

.section-summary .sum {
    color: var(--text-primary);
    font-variant-numeric: tabular-nums;
}

/* Total summary */
.summary {
    background: var(--bg-secondary);
    padding: 20px 24px;
    border-radius: var(--radius-lg);
    display: flex;
    gap: 32px;
    align-items: center;
    flex-wrap: wrap;
}

.summary p {
    margin: 0;
    font-size: 14px;
    color: var(--text-secondary);
}

.summary p strong {
    color: var(--text-primary);
    font-size: 16px;
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-muted);
}

/* Saved indicator */
.saved {
    animation: flash-save 0.3s ease;
}

@keyframes flash-save {
    0% { background-color: #d1fae5; }
    100% { background-color: transparent; }
}

/* Checkbox styling */
input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: var(--accent-blue);
}

/* Responsive */
@media (max-width: 1200px) {
    .container { padding: 16px; }
    .edit-description { width: 140px; }
}

@media (max-width: 900px) {
    .edit-description { width: 100px; }
    .edit-category { width: 100px; }
}
</style>

<script>
// Data from server
const categories = {{ categories|tojson|safe if categories else '[]' }};
const accounts = {{ accounts|tojson|safe if accounts else '[]' }};
const posterAccounts = {{ poster_accounts|tojson|safe if poster_accounts else '[]' }};
const posterTransactions = {{ poster_transactions|tojson|safe if poster_transactions else '[]' }};

console.log('Loaded categories:', categories.length, categories);
console.log('Loaded accounts:', accounts.length);
console.log('Loaded poster accounts:', posterAccounts.length);
console.log('Loaded poster transactions:', posterTransactions.length);
// Debug: show structure of first expense transaction
const firstExpense = posterTransactions.find(t => t.type == 0 || t.type == '0');
if (firstExpense) console.log('Sample expense transaction:', firstExpense);

// Map Poster system category names to human-readable names
const categoryNameMap = {
    'book_category_action_marketing': '–ú–∞—Ä–∫–µ—Ç–∏–Ω–≥',
    'book_category_action_banking_services': '–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ —É—Å–ª—É–≥–∏ –∏ –∫–æ–º–∏—Å—Å–∏–∏',
    'book_category_action_household_expenses': '–•–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã',
    'book_category_action_rent': '–ê—Ä–µ–Ω–¥–∞',
    'book_category_action_utility_bills': '–ö–æ–º–º—É–Ω–∞–ª—å–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏',
    'book_category_action_labour_cost': '–ó–∞—Ä–ø–ª–∞—Ç–∞',
    'book_category_action_supplies': '–ü–æ—Å—Ç–∞–≤–∫–∏',
    'book_category_action_actualization': '–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è'
};

// Helper to get readable category name
function getCategoryName(cat) {
    const rawName = cat.category_name || cat.name || '';
    return categoryNameMap[rawName] || rawName;
}

let searchTimeout = null;

// Helper to find matching transactions in Poster
function findSyncStatus(amount, description, category, accountId, posterAccountId, expenseType) {
    // Find finance account name by accountId
    const financeAccount = accounts.find(a => a.account_id == accountId);
    const accountName = financeAccount ? (financeAccount.name || '').toLowerCase() : '';
    const descLower = (description || '').toLowerCase().trim();

    // Special handling for supplies - look for split supply transactions
    if (expenseType === 'supply') {
        return findSupplySyncStatus(amount, descLower, category, accountName);
    }

    // Regular transaction matching
    let bestMatch = { matches: 0, transaction: null };

    for (const t of posterTransactions) {
        // Filter by poster account if specified
        if (posterAccountId && t.poster_account_id != posterAccountId) continue;

        // Only check expenses (type 0)
        if (t.type != 0 && t.type != '0') continue;

        let matches = 0;

        // 1. Check amount (Poster stores in kopecks/tiyn, divide by 100)
        const tAmountRaw = parseFloat(t.amount) || 0;
        const tAmount = Math.abs(tAmountRaw) / 100;  // Convert from kopecks and absolute value
        if (Math.abs(tAmount - amount) < 10) {  // Allow 10‚Ç∏ tolerance
            matches++;
        }

        // 2. Check comment/description
        const tComment = (t.comment || '').toLowerCase().trim();
        if (tComment && descLower && (tComment.includes(descLower) || descLower.includes(tComment) || tComment === descLower)) {
            matches++;
        }

        // 3. Check category
        const tCategoryName = (t.category_name || '').toLowerCase();
        const catLower = (category || '').toLowerCase();
        if (tCategoryName && catLower && (tCategoryName.includes(catLower) || catLower.includes(tCategoryName))) {
            matches++;
        }

        // 4. Check account (field is "account_name", not "account_from_name")
        const tAccountName = (t.account_name || '').toLowerCase();
        if (accountName && tAccountName && (tAccountName.includes(accountName) || accountName.includes(tAccountName))) {
            matches++;
        }

        if (matches > bestMatch.matches) {
            bestMatch = { matches, transaction: t };
        }

        // Early exit if full match
        if (matches === 4) break;
    }

    return bestMatch.matches;
}

// Special sync status for supplies - can be split across multiple accounts
// Example: "–Ø–ø–æ—à–∞ 125000" expense might match transactions:
//   - "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññ4824 –æ—Ç ¬´–Ø–ø–æ—à–∞ ¬ª" 60000‚Ç∏ in PizzBurg
//   - "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññ4825 –æ—Ç ¬´–Ø–ø–æ—à–∞ ¬ª" 65000‚Ç∏ in PizzBurg-Cafe
// Sum = 125000‚Ç∏ = expense amount
function findSupplySyncStatus(expenseAmount, supplierName, category, accountName) {
    if (!supplierName) return 0;

    // Find all transactions that look like supply transactions with this supplier
    // Pattern: "–ü–æ—Å—Ç–∞–≤–∫–∞ ‚Ññxxx –æ—Ç ¬´Supplier ¬ª" or just contains supplier name
    const supplyTransactions = posterTransactions.filter(t => {
        if (t.type != 0 && t.type != '0') return false;

        const comment = (t.comment || '').toLowerCase();
        // Match "–ø–æ—Å—Ç–∞–≤–∫–∞" + supplier name
        const isSupplyComment = comment.includes('–ø–æ—Å—Ç–∞–≤–∫–∞') && comment.includes(supplierName);
        // Or direct supplier name match in comment
        const hasSupplierName = comment.includes(supplierName);

        return isSupplyComment || hasSupplierName;
    });

    if (supplyTransactions.length === 0) return 0;

    // Sum up all matching supply transaction amounts (convert from kopecks)
    const totalSupplyAmount = supplyTransactions.reduce((sum, t) => {
        const amountRaw = parseFloat(t.amount) || 0;
        return sum + Math.abs(amountRaw) / 100;  // Convert from kopecks
    }, 0);

    // Check category matches
    const catLower = (category || '').toLowerCase();
    let categoryMatches = false;
    for (const t of supplyTransactions) {
        const tCategoryName = (t.category_name || '').toLowerCase();
        if (tCategoryName && catLower && (tCategoryName.includes(catLower) || catLower.includes(tCategoryName))) {
            categoryMatches = true;
            break;
        }
        // Also match if category is "–ø–æ—Å—Ç–∞–≤–∫–∞" (common for supplies)
        if (tCategoryName.includes('–ø–æ—Å—Ç–∞–≤–∫–∞') || tCategoryName.includes('—Ç–æ–≤–∞—Ä')) {
            categoryMatches = true;
            break;
        }
    }

    // Check account matches (field is "account_name")
    let accountMatches = false;
    for (const t of supplyTransactions) {
        const tAccountName = (t.account_name || '').toLowerCase();
        if (accountName && tAccountName && (tAccountName.includes(accountName) || accountName.includes(tAccountName))) {
            accountMatches = true;
            break;
        }
    }

    // Calculate match score
    let matches = 0;

    // 1. Amount - check if sum of supply transactions matches expense amount (with tolerance)
    if (Math.abs(totalSupplyAmount - expenseAmount) < 2) {
        matches++;
    } else if (totalSupplyAmount > 0 && Math.abs(totalSupplyAmount - expenseAmount) < expenseAmount * 0.01) {
        // 1% tolerance
        matches++;
    }

    // 2. Supplier name match (we already filtered by this, so it's a match)
    matches++;

    // 3. Category
    if (categoryMatches) matches++;

    // 4. Account
    if (accountMatches) matches++;

    return matches;
}

// Update row sync status
function updateRowSyncStatus(row) {
    const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
    const description = row.querySelector('.edit-description').value;
    const category = row.querySelector('.edit-category').value;
    // Get account_id from row dataset (set based on section)
    const accountId = row.dataset.accountId || null;
    const posterAccountSelect = row.querySelector('.edit-poster-account');
    const posterAccountId = posterAccountSelect ? posterAccountSelect.value : null;

    // Get expense type from the type button
    const typeBtn = row.querySelector('.btn-type');
    const expenseType = typeBtn ? typeBtn.dataset.type : 'transaction';

    const matches = findSyncStatus(amount, description, category, accountId, posterAccountId, expenseType);

    // Debug: log first few rows
    if (amount > 1000) {
        console.log(`Sync check: ${amount}‚Ç∏ "${description}" cat="${category}" => ${matches} matches`);
    }

    row.classList.remove('sync-full', 'sync-partial');
    if (matches >= 4) {
        row.classList.add('sync-full');
    } else if (matches >= 3) {
        row.classList.add('sync-partial');
    }
}

// Update all rows sync status
function updateAllSyncStatus() {
    document.querySelectorAll('.draft-row').forEach(row => {
        updateRowSyncStatus(row);
    });
}

// Map account type to account_id (will be set from accounts data)
const accountTypeMap = {
    cash: null,
    kaspi: null,
    halyk: null
};

// Find account IDs for each type
accounts.forEach(acc => {
    const name = (acc.name || '').toLowerCase();
    if (name.includes('kaspi')) {
        if (!accountTypeMap.kaspi) accountTypeMap.kaspi = acc.account_id;
    } else if (name.includes('—Ö–∞–ª—ã–∫') || name.includes('halyk')) {
        if (!accountTypeMap.halyk) accountTypeMap.halyk = acc.account_id;
    } else if (name.includes('–Ω–∞–ª–∏—á–∫') || name.includes('–∑–∞–∫—É–ø') || name.includes('cash')) {
        if (!accountTypeMap.cash) accountTypeMap.cash = acc.account_id;
    }
});

// Fallback: if cash not found, use first non-kaspi/non-halyk account
if (!accountTypeMap.cash) {
    const cashAcc = accounts.find(acc => {
        const name = (acc.name || '').toLowerCase();
        return !name.includes('kaspi') && !name.includes('—Ö–∞–ª—ã–∫') && !name.includes('halyk');
    });
    if (cashAcc) accountTypeMap.cash = cashAcc.account_id;
}

// Debug: show accounts and mapping
console.log('Available accounts:', accounts.map(a => ({ id: a.account_id, name: a.name })));
console.log('Account type mapping:', accountTypeMap);

document.addEventListener('DOMContentLoaded', function() {
    // Initial sync status check
    updateAllSyncStatus();

    // Section checkboxes
    const countSpan = document.getElementById('count');

    function updateCount() {
        const checked = document.querySelectorAll('.draft-checkbox:checked').length;
        countSpan.textContent = checked;
    }

    function updateSummary() {
        const rows = document.querySelectorAll('.draft-row');
        let total = 0;
        let transactions = 0;
        let supplies = 0;

        // Section totals
        const sectionTotals = { cash: 0, kaspi: 0, halyk: 0 };

        rows.forEach(row => {
            const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
            total += amount;
            if (row.classList.contains('supply')) {
                supplies++;
            } else {
                transactions++;
            }
            // Add to section total
            const accountType = row.dataset.accountType || 'cash';
            if (sectionTotals.hasOwnProperty(accountType)) {
                sectionTotals[accountType] += amount;
            }
        });

        document.getElementById('total-count').textContent = rows.length;
        document.getElementById('transaction-count').textContent = transactions;
        document.getElementById('supply-count').textContent = supplies;
        document.getElementById('total-sum').textContent = total.toLocaleString('ru-RU');

        // Update section summaries
        for (const [type, sum] of Object.entries(sectionTotals)) {
            const summaryEl = document.querySelector(`#summary-${type} .sum`);
            if (summaryEl) {
                summaryEl.textContent = sum.toLocaleString('ru-RU') + '‚Ç∏';
            }
        }
    }

    // Section select-all checkboxes
    document.querySelectorAll('.select-all-section').forEach(cb => {
        cb.addEventListener('change', function() {
            const section = this.dataset.section;
            const tbody = document.getElementById(`drafts-tbody-${section}`);
            if (tbody) {
                tbody.querySelectorAll('.draft-checkbox').forEach(dcb => dcb.checked = this.checked);
            }
            updateCount();
        });
    });

    document.addEventListener('change', function(e) {
        if (e.target.classList.contains('draft-checkbox')) {
            updateCount();
        }
    });

    // DON'T auto-create empty rows on page load - they accumulate in database
    // Empty rows are created only when user fills the last row in a section
    updateSummary();

    // Toggle type buttons - use event delegation
    document.addEventListener('click', async function(e) {
        if (e.target.classList.contains('btn-type')) {
            const btn = e.target;
            const id = btn.dataset.id;
            const currentType = btn.dataset.type;
            const newType = currentType === 'supply' ? 'transaction' : 'supply';

            try {
                const response = await fetch(`/expenses/toggle-type/${id}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({expense_type: newType})
                });

                if (response.ok) {
                    btn.dataset.type = newType;
                    btn.innerHTML = newType === 'supply' ? 'üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞' : 'üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è';

                    const row = btn.closest('tr');
                    row.classList.remove('supply', 'transaction');
                    row.classList.add(newType);
                    updateSummary();
                }
            } catch (e) {
                console.error('Error:', e);
            }
        }

        // Delete button
        if (e.target.classList.contains('btn-delete')) {
            if (!confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —á–µ—Ä–Ω–æ–≤–∏–∫?')) return;

            const id = e.target.dataset.id;
            try {
                const response = await fetch(`/expenses/delete/${id}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    e.target.closest('tr').remove();
                    updateSummary();
                }
            } catch (err) {
                console.error('Error:', err);
            }
        }

        // Completion status toggle: pending ‚Üí partial ‚Üí completed ‚Üí pending
        if (e.target.classList.contains('btn-completion')) {
            const btn = e.target;
            const id = btn.dataset.id;
            const currentStatus = btn.dataset.status || 'pending';

            // Cycle through statuses
            const nextStatus = currentStatus === 'pending' ? 'partial' :
                              currentStatus === 'partial' ? 'completed' : 'pending';
            const statusIcons = { pending: '‚ö™', partial: 'üü°', completed: '‚úÖ' };

            try {
                const response = await fetch(`/expenses/update/${id}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ completion_status: nextStatus })
                });

                if (response.ok) {
                    btn.dataset.status = nextStatus;
                    btn.textContent = statusIcons[nextStatus];

                    const row = btn.closest('tr');
                    row.classList.remove('pending', 'partial', 'completed');
                    row.classList.add(nextStatus);
                    row.dataset.completionStatus = nextStatus;
                }
            } catch (err) {
                console.error('Error:', err);
            }
        }
    });

    // Clear '0' on focus for amount fields - user expects empty field to type into
    document.addEventListener('focus', function(e) {
        if (e.target.classList.contains('edit-amount')) {
            const input = e.target;
            if (input.value === '0') {
                input.value = '';
            }
        }
    }, true);

    // Detect when user fills an empty row -> ensure new empty row exists in that section
    // Debounced to prevent multiple rapid calls
    let ensureRowTimeout = null;
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('edit-amount') || e.target.classList.contains('edit-description')) {
            const row = e.target.closest('tr');
            const tbody = row?.parentElement;
            if (!tbody) return;

            // Check if this is the last row in this section
            const rows = tbody.querySelectorAll('.draft-row');
            if (rows.length > 0 && rows[rows.length - 1] === row) {
                // User is filling the last row, ensure there's a new empty row in this section
                const accountType = tbody.dataset.accountType || 'cash';

                // Debounce the call
                clearTimeout(ensureRowTimeout);
                ensureRowTimeout = setTimeout(() => {
                    ensureEmptyRowInSection(accountType);
                }, 300);
            }
        }
    });

    // Amount editing - use event delegation
    document.addEventListener('change', async function(e) {
        if (e.target.classList.contains('edit-amount')) {
            const input = e.target;
            const id = input.dataset.id;
            await updateField(id, 'amount', input.value);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateSummary();
            updateRowSyncStatus(input.closest('tr'));
        }

        // Description editing
        if (e.target.classList.contains('edit-description')) {
            const input = e.target;
            const id = input.dataset.id;
            await updateField(id, 'description', input.value);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateRowSyncStatus(input.closest('tr'));
        }

        // Poster account select (department change)
        if (e.target.classList.contains('edit-poster-account')) {
            const select = e.target;
            const id = select.dataset.id;
            const posterAccountId = select.value;
            await updateField(id, 'poster_account_id', posterAccountId);
            select.classList.add('saved');
            setTimeout(() => select.classList.remove('saved'), 300);
            const row = select.closest('tr');
            updateRowSyncStatus(row);
        }
    });

    // Category autocomplete - use event delegation
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;

            clearTimeout(searchTimeout);
            const query = input.value.toLowerCase().trim();

            if (query.length < 1) {
                resultsDiv.style.display = 'none';
                return;
            }

            // Get selected poster account to filter categories
            const row = input.closest('tr');
            const posterAccountSelect = row?.querySelector('.edit-poster-account');
            const selectedPosterAccountId = posterAccountSelect ? parseInt(posterAccountSelect.value) : null;

            searchTimeout = setTimeout(() => {
                // Find ALL matching categories (don't strictly filter by department)
                let matches = categories.filter(c => {
                    const displayName = getCategoryName(c);
                    return displayName.toLowerCase().includes(query);
                });

                // Sort: selected department first, then alphabetically
                matches.sort((a, b) => {
                    const aMatch = a.poster_account_id == selectedPosterAccountId ? 0 : 1;
                    const bMatch = b.poster_account_id == selectedPosterAccountId ? 0 : 1;
                    if (aMatch !== bMatch) return aMatch - bMatch;
                    const aName = getCategoryName(a).toLowerCase();
                    const bName = getCategoryName(b).toLowerCase();
                    return aName.localeCompare(bName);
                });

                // Deduplicate by display name (keep first, which is from selected department)
                const seen = new Set();
                matches = matches.filter(c => {
                    const displayName = getCategoryName(c).toLowerCase();
                    if (seen.has(displayName)) return false;
                    seen.add(displayName);
                    return true;
                }).slice(0, 10);

                if (matches.length === 0) {
                    resultsDiv.innerHTML = `<div class="autocomplete-item" data-name="${input.value}">‚ûï –î–æ–±–∞–≤–∏—Ç—å "${input.value}"</div>`;
                } else {
                    resultsDiv.innerHTML = matches.map((c, i) => {
                        const displayName = getCategoryName(c);
                        const isOtherDept = selectedPosterAccountId && c.poster_account_id && c.poster_account_id != selectedPosterAccountId;
                        const accountTag = isOtherDept && c.poster_account_name ? ` <small style="color:#999">(${c.poster_account_name})</small>` : '';
                        return `<div class="autocomplete-item" data-name="${displayName}" data-index="${i}">${displayName}${accountTag}</div>`;
                    }).join('');
                }
                resultsDiv.style.display = 'block';
            }, 100);
        }
    });

    // Category autocomplete click
    document.addEventListener('click', async function(e) {
        if (e.target.classList.contains('autocomplete-item')) {
            const item = e.target;
            const wrapper = item.closest('.autocomplete-wrapper');
            const input = wrapper.querySelector('.edit-category');
            const resultsDiv = wrapper.querySelector('.autocomplete-results');

            const name = item.dataset.name;
            input.value = name;
            resultsDiv.style.display = 'none';

            const id = input.dataset.id;
            await updateField(id, 'category', name);
            input.classList.add('saved');
            setTimeout(() => input.classList.remove('saved'), 300);
            updateRowSyncStatus(input.closest('tr'));
        }
    });

    // Category blur - save and close
    document.addEventListener('blur', async function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;

            setTimeout(async () => {
                resultsDiv.style.display = 'none';
                // Save value
                const id = input.dataset.id;
                await updateField(id, 'category', input.value);
                updateRowSyncStatus(input.closest('tr'));
            }, 200);
        }
    }, true);

    // Category keyboard navigation
    document.addEventListener('keydown', function(e) {
        if (e.target.classList.contains('edit-category')) {
            const input = e.target;
            const resultsDiv = input.nextElementSibling;
            const items = resultsDiv.querySelectorAll('.autocomplete-item');

            if (items.length === 0) return;

            let selectedIndex = Array.from(items).findIndex(item => item.classList.contains('active'));

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                items.forEach((item, i) => item.classList.toggle('active', i === selectedIndex));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, 0);
                items.forEach((item, i) => item.classList.toggle('active', i === selectedIndex));
            } else if (e.key === 'Enter' || e.key === 'Tab') {
                if (selectedIndex >= 0 && items[selectedIndex]) {
                    e.preventDefault();
                    items[selectedIndex].click();
                } else if (items.length === 1) {
                    e.preventDefault();
                    items[0].click();
                }
            } else if (e.key === 'Escape') {
                resultsDiv.style.display = 'none';
            }
        }
    });
});

async function updateField(id, field, value) {
    try {
        const data = {};
        data[field] = value;

        await fetch(`/expenses/update/${id}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
    } catch (e) {
        console.error('Error updating field:', e);
    }
}

// Track pending row creations to prevent duplicates
const pendingRowCreation = { cash: false, kaspi: false, halyk: false };

// Create new row dynamically for a specific section
async function addNewRow(accountType = 'cash', focusAmount = true) {
    // Prevent duplicate row creation
    if (pendingRowCreation[accountType]) {
        return null;
    }
    pendingRowCreation[accountType] = true;

    try {
        // Get account_id for this section
        const accountId = accountTypeMap[accountType];

        const response = await fetch('/expenses/create', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ account_id: accountId })
        });

        const result = await response.json();
        if (result.success) {
            // Add account_type to the draft for createRowElement
            result.draft.account_type = accountType;
            const newRow = createRowElement(result.draft);
            const tbody = document.getElementById(`drafts-tbody-${accountType}`);
            if (tbody) {
                tbody.appendChild(newRow);
            }

            if (focusAmount) {
                const amountInput = newRow.querySelector('.edit-amount');
                if (amountInput) amountInput.focus();
            }

            updateSummaryGlobal();
            return newRow;
        } else {
            console.error('Error creating row:', result.error);
            return null;
        }
    } catch (e) {
        console.error('Error:', e);
        return null;
    } finally {
        pendingRowCreation[accountType] = false;
    }
}

// Ensure there's always an empty row at the bottom of a section
function ensureEmptyRowInSection(accountType) {
    const tbody = document.getElementById(`drafts-tbody-${accountType}`);
    if (!tbody) return;

    // Check if last row is empty (amount = 0 and description empty)
    const rows = tbody.querySelectorAll('.draft-row');
    if (rows.length > 0) {
        const lastRow = rows[rows.length - 1];
        const amount = parseFloat(lastRow.querySelector('.edit-amount')?.value) || 0;
        const desc = lastRow.querySelector('.edit-description')?.value?.trim() || '';

        if (amount === 0 && desc === '') {
            // Last row is already empty
            return;
        }
    }

    // Add new empty row in this section
    addNewRow(accountType, false);
}

// Ensure empty rows in all sections
function ensureEmptyRowInAllSections() {
    ['cash', 'kaspi', 'halyk'].forEach(type => {
        ensureEmptyRowInSection(type);
    });
}

// Create row element from draft data
function createRowElement(draft) {
    const tr = document.createElement('tr');
    const completionStatus = draft.completion_status || 'pending';
    const accountType = draft.account_type || 'cash';
    tr.className = 'draft-row ' + (draft.expense_type === 'supply' ? 'supply' : 'transaction') + ' ' + completionStatus;
    tr.dataset.id = draft.id;
    tr.dataset.amount = draft.amount || 0;
    tr.dataset.description = draft.description || '';
    tr.dataset.category = draft.category || '';
    tr.dataset.accountId = draft.account_id || '';
    tr.dataset.posterAccountId = draft.poster_account_id || '';
    tr.dataset.completionStatus = completionStatus;
    tr.dataset.accountType = accountType;

    // Build poster accounts options
    let posterAccountOptions = '';
    posterAccounts.forEach(pa => {
        const selected = pa.id == draft.poster_account_id || (!draft.poster_account_id && pa.is_primary) ? 'selected' : '';
        posterAccountOptions += `<option value="${pa.id}" ${selected}>${pa.name}</option>`;
    });

    // Completion status icon
    const statusIcons = { pending: '‚ö™', partial: 'üü°', completed: '‚úÖ' };
    const statusIcon = statusIcons[completionStatus] || '‚ö™';

    tr.innerHTML = `
        <td>
            <input type="checkbox" name="draft_ids" value="${draft.id}" class="draft-checkbox">
        </td>
        <td class="completion-status">
            <button type="button" class="btn-completion" data-id="${draft.id}" data-status="${completionStatus}" title="–°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è">
                ${statusIcon}
            </button>
        </td>
        <td class="amount">
            <input type="number" class="edit-amount" value="${draft.amount || 0}"
                   data-id="${draft.id}" step="1" min="0">
        </td>
        <td class="description">
            <input type="text" class="edit-description" value="${draft.description || ''}"
                   data-id="${draft.id}">
        </td>
        <td class="type">
            <button type="button" class="btn-type"
                    data-id="${draft.id}"
                    data-type="${draft.expense_type || 'transaction'}">
                ${draft.expense_type === 'supply' ? 'üì¶ –ø–æ—Å—Ç–∞–≤–∫–∞' : 'üí∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è'}
            </button>
        </td>
        <td class="category">
            <div class="autocomplete-wrapper">
                <input type="text" class="edit-category"
                       value="${draft.category || ''}"
                       data-id="${draft.id}"
                       placeholder="–ö–∞—Ç–µ–≥–æ—Ä–∏—è..."
                       autocomplete="off">
                <div class="autocomplete-results"></div>
            </div>
        </td>
        <td class="poster-account">
            <select class="edit-poster-account" data-id="${draft.id}">
                ${posterAccountOptions}
            </select>
        </td>
        <td class="actions">
            <button type="button" class="btn-delete" data-id="${draft.id}" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
        </td>
    `;

    return tr;
}

function updateSummaryGlobal() {
    const rows = document.querySelectorAll('.draft-row');
    let total = 0;
    let transactions = 0;
    let supplies = 0;

    rows.forEach(row => {
        const amount = parseFloat(row.querySelector('.edit-amount').value) || 0;
        total += amount;
        if (row.classList.contains('supply')) {
            supplies++;
        } else {
            transactions++;
        }
    });

    document.getElementById('total-count').textContent = rows.length;
    document.getElementById('transaction-count').textContent = transactions;
    document.getElementById('supply-count').textContent = supplies;
    document.getElementById('total-sum').textContent = total.toLocaleString('ru-RU');
}

// ============ SORTING FUNCTIONALITY ============

// Track sort state per section: { cash: { column: 'amount', direction: 'asc' }, ... }
const sortState = {
    cash: { column: null, direction: null },
    kaspi: { column: null, direction: null },
    halyk: { column: null, direction: null }
};

// Get value for sorting from a row
function getSortValue(row, column) {
    switch (column) {
        case 'amount':
            return parseFloat(row.querySelector('.edit-amount')?.value) || 0;
        case 'description':
            return (row.querySelector('.edit-description')?.value || '').toLowerCase();
        case 'type':
            const typeBtn = row.querySelector('.btn-type');
            return typeBtn ? typeBtn.dataset.type : '';
        case 'category':
            return (row.querySelector('.edit-category')?.value || '').toLowerCase();
        case 'department':
            const select = row.querySelector('.edit-poster-account');
            return select ? (select.options[select.selectedIndex]?.text || '').toLowerCase() : '';
        default:
            return '';
    }
}

// Sort rows in a section
function sortSection(section, column) {
    const state = sortState[section];
    const tbody = document.getElementById(`drafts-tbody-${section}`);
    if (!tbody) return;

    // Determine new direction: none -> asc -> desc -> none
    let newDirection;
    if (state.column !== column) {
        newDirection = 'asc';
    } else if (state.direction === 'asc') {
        newDirection = 'desc';
    } else if (state.direction === 'desc') {
        newDirection = null;
    } else {
        newDirection = 'asc';
    }

    // Update state
    state.column = newDirection ? column : null;
    state.direction = newDirection;

    // Update header icons
    updateSortIcons(section, column, newDirection);

    // Get all rows (excluding empty rows at the end)
    const rows = Array.from(tbody.querySelectorAll('.draft-row'));

    // Separate empty rows (amount=0 and no description) to keep them at the end
    const emptyRows = [];
    const dataRows = [];
    rows.forEach(row => {
        const amount = parseFloat(row.querySelector('.edit-amount')?.value) || 0;
        const desc = (row.querySelector('.edit-description')?.value || '').trim();
        if (amount === 0 && desc === '') {
            emptyRows.push(row);
        } else {
            dataRows.push(row);
        }
    });

    // Sort data rows if direction is set
    if (newDirection) {
        dataRows.sort((a, b) => {
            const aVal = getSortValue(a, column);
            const bVal = getSortValue(b, column);

            let comparison;
            if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                comparison = String(aVal).localeCompare(String(bVal), 'ru');
            }

            return newDirection === 'desc' ? -comparison : comparison;
        });
    }

    // Re-append rows in sorted order (data rows first, then empty rows)
    [...dataRows, ...emptyRows].forEach(row => tbody.appendChild(row));
}

// Update sort icons in headers
function updateSortIcons(section, activeColumn, direction) {
    const sectionEl = document.querySelector(`.account-section[data-account-type="${section}"]`);
    if (!sectionEl) return;

    sectionEl.querySelectorAll('th.sortable').forEach(th => {
        const col = th.dataset.sort;
        const icon = th.querySelector('.sort-icon');

        th.classList.remove('sort-asc', 'sort-desc');

        if (col === activeColumn && direction) {
            th.classList.add(`sort-${direction}`);
            icon.textContent = direction === 'asc' ? '‚Üë' : '‚Üì';
        } else {
            icon.textContent = '‚Üï';
        }
    });
}

// Add click handlers to sortable headers
document.querySelectorAll('th.sortable').forEach(th => {
    th.addEventListener('click', function() {
        const section = this.dataset.section;
        const column = this.dataset.sort;
        sortSection(section, column);
    });
});
</script>
{% endblock %}
